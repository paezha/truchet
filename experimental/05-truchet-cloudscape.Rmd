---
title: "R Notebook"
output: html_document
---

```{r}
seed <- sample.int(100000, 1)
set.seed(seed)
```

Load packages:
```{r load-packages, warning=FALSE}
library(ggplot2)
library(igraph)
library(imager)
library(dplyr)
library(lwgeom)
library(MexBrewer)
library(purrr)
library(sf)
library(truchet)
```

## Create a collage of truchet mossaics

Read the image using `imager::load.image()`:
```{r}
clouds <- load.image("clouds.jpg")
```

Image info:
```{r}
clouds
```

Resize image:
```{r}
clouds_rs <- imresize(clouds, scale = 1/10, interpolation = 6)
```

Convert to grayscale:
```{r}
clouds.g <- grayscale(clouds_rs)
```

Convert to data frame:
```{r}
df <- clouds_rs %>%
  grayscale() %>% 
  as.data.frame() %>%
  mutate(y = -(y - max(y)))
```

Convert the data frame to simple features:
```{r}
df_sf <- df %>%
  st_as_sf(coords = c("x", "y")) %>%
  cbind(df %>% select(x, y))
```

Identify paths for blades to split image:
```{r}
# This chunk was adapted from the tutorial of {imager}; see: https://dahtah.github.io/imager/gimptools.html#magic-scissors

im <- clouds.g

##The following function makes a data.frame of links between pixel (x,y) and pixel (x+dx,y+dy)
##I'm sure there's a better way of doing things
make.df <- function(dx,dy){
  (abs(im-imshift(im,dx,dy))) %>%
    as.data.frame() %>%
    mutate(x.to = x-dx, y.to = y-dy, id.from = paste(x,y,sep=","), id.to = paste(x.to,y.to,sep=",")) %>%
    dplyr::select(id.from, id.to, value) %>%
    dplyr::rename(weight=value)}

# Path 1
## Get all neighbours, convert data.frame to graph
G <- cross2(-1:1,-1:1,function(a,b) abs(a) +abs(b) == 0) %>%
  map_df(lift(function(dx,dy) mutate(make.df(dx,dy),dx=dx,dy=dy))) %>%
  mutate(weight = 1/(weight + 0.01)^7)#exp(-0.05 * weight))

G <- G %>%
  graph_from_data_frame()

#Extract shortest paths
path_1 <- shortest_paths(G,"1,140","258,150") %$% V(G)[vpath[[1]]]%>%
  names %>% stringr::str_split(",") %>%
  map_df(~ data.frame(x=as.integer(.[[1]]),y=as.integer(.[[2]])))

# Path 2
## Get all neighbours, convert data.frame to graph
G <- cross2(-1:1,-1:1,function(a,b) abs(a) +abs(b) == 0) %>%
  map_df(lift(function(dx,dy) mutate(make.df(dx,dy),dx=dx,dy=dy))) %>%
  mutate(weight = 1/(weight + 0.01)^1)#exp(-0.05 * weight))

G <- G %>%
  graph_from_data_frame()

#Extract shortest paths
path_2 <- shortest_paths(G,"1,150","258,150") %$% V(G)[vpath[[1]]]%>%
  names %>% stringr::str_split(",") %>%
  map_df(~ data.frame(x=as.integer(.[[1]]),y=as.integer(.[[2]])))

# Path 3
## Get all neighbours, convert data.frame to graph
G <- cross2(-1:1,-1:1,function(a,b) abs(a) +abs(b) == 0) %>%
  map_df(lift(function(dx,dy) mutate(make.df(dx,dy),dx=dx,dy=dy))) %>%
  mutate(weight = 1/(weight + 0.01)^2)#exp(-0.05 * weight))

G <- G %>%
  graph_from_data_frame()

#Extract shortest paths
path_3 <- shortest_paths(G,"1,205","258,200") %$% V(G)[vpath[[1]]]%>%
  names %>% stringr::str_split(",") %>%
  map_df(~ data.frame(x=as.integer(.[[1]]),y=as.integer(.[[2]])))
```

Check the paths:
```{r eval=FALSE}
plot(im)
lines(path_1$x,path_1$y,col="green",lty=2,lwd=2)
lines(path_2$x,path_2$y,col="red",lty=2,lwd=2)
lines(path_3$x,path_3$y,col="blue",lty=2,lwd=2)
```

Reverse the y axis of the paths and shift the y coordinates:
```{r}
path_1 <- path_1 %>%
  mutate(y = -(y - max(y)) + 107)

path_2 <- path_2 %>%
  mutate(y = -(y - max(y)) + 68)

path_3 <- path_3 %>%
  mutate(y = -(y - max(y)) + 30)
```

Convert paths to simple features:
```{r}
path_1 <- data.frame(path = "1", 
                     st_linestring(x = as.matrix(path_1)) %>%
                       st_geometry()) %>%
  st_sf()

path_2 <- data.frame(path = "2", 
                     st_linestring(x = as.matrix(path_2)) %>%
                       st_geometry()) %>%
  st_sf()

path_3 <- data.frame(path = "3", 
                     st_linestring(x = as.matrix(path_3)) %>%
                       st_geometry()) %>%
  st_sf()


# Put together
paths <- rbind(path_1 ,
               path_2,
               path_3) %>%
  # Simplify paths
  st_simplify(dTolerance = 2)
```

Create container:
```{r}
container <- matrix(c(min(df$x) + 1, min(df$y) + 2,
                      min(df$x) + 1, max(df$y) - 2,
                      max(df$x) - 2, max(df$y) - 2,
                      max(df$x) - 2, min(df$y) + 2,
                      min(df$x) + 1, min(df$y) + 2),
                    ncol = 2,
                    byrow = TRUE)

# Convert coordinates to polygons and then to simple features
container <- data.frame(geometry = sf::st_polygon(list(container)) %>%
                          sf::st_sfc()) %>%
  sf::st_as_sf()
```

Use the paths to split the container:
```{r}
container <- container %>%
  st_split(paths) %>%
  st_collection_extract() %>%
  mutate(id = 1:n())
```

Spatial join the data frame with the image. Create buffers of the parts of the cointainer to have some overlap between the mosaics to avoid blanks in the final mosaic:
```{r}
df_sf <- df_sf %>%
  st_join(container)

df_1_sf <- df_sf %>%
  select(-id) %>%
  st_join(container %>%
            filter(id == "1") %>%
            st_buffer(dist = 10))

df_2_sf <- df_sf %>%
  select(-id) %>%
  st_join(container %>%
            filter(id == "2") %>%
            st_buffer(dist = 10))

df_3_sf <- df_sf %>%
  select(-id) %>%
  st_join(container %>%
            filter(id == "3") %>%
            st_buffer(dist = 10))

df_4_sf <- df_sf %>%
  select(-id) %>%
  st_join(container %>%
            filter(id == "4") %>%
            st_buffer(dist = 10))
```

Create data frames for the mosaic:
```{r}
# This will use a smaller subset of points to create the mosaic, which will then be rescaled
s <- 15

# Create a data frame with the spots for tiles
m_4 <- df_4_sf %>%
  filter(id == 4, 
         x %% s == 0, 
         y %% s == 0) %>%
  mutate(x = x/s,
         y = y/s,
         tiles = sample(c("-", "|", "tn"), n(), replace = TRUE),
         scale_p = 1)

m_3 <- df_3_sf %>%
  filter(id == 3, 
         x %% s == 0, 
         y %% s == 0) %>%
  mutate(x = x/s,
         y = y/s,
         tiles = sample(c("fse", "fsw", "+"), n(), replace = TRUE),
         scale_p = 1)

m_2 <- df_2_sf %>%
  filter(id == 2, 
         x %% s == 0, 
         y %% s == 0) %>%
  mutate(x = x/s,
         y = y/s,
         tiles = sample(c("dl", "dr"), n(), replace = TRUE),
         scale_p = 1)

m_1 <- df_1_sf %>%
  filter(id == 1, 
         x %% s == 0, 
         y %% s == 0) %>%
  mutate(x = x/s,
         y = y/s,
         tiles = sample(c("fne", "fnw", "+"), n(), replace = TRUE),
         scale_p = 1)
```

Create mosaic using the designed container:
```{r}
# Part 4
m_4 <- st_truchet_ms(df = m_4 %>% 
                       st_drop_geometry()) %>%
  st_truchet_dissolve()

# Part 3
m_3 <- st_truchet_ms(df = m_3 %>% 
                       st_drop_geometry()) %>%
  st_truchet_dissolve()

# Part 2
m_2 <- st_truchet_ms(df = m_2 %>% 
                       st_drop_geometry()) %>%
  st_truchet_dissolve()

# Part 1
m_1 <- st_truchet_ms(df = m_1 %>% 
                       st_drop_geometry()) %>%
  st_truchet_dissolve()

```

Plot:
```{r eval = FALSE}
ggplot() + 
  geom_sf(data = m_4) + 
  geom_sf(data = m_3) + 
  geom_sf(data = m_2) + 
  geom_sf(data = m_1) 
```

Dissolve and buffer:
```{r}
# Container 4
m_4b1 <- m_4 %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_4b1 <- m_4b1[!st_is_empty(m_4b1), , drop = FALSE]

m_4b2 <- m_4b1 %>% 
  st_truchet_dissolve() %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_4b2 <- m_4b2[!st_is_empty(m_4b2), , drop = FALSE]

# Container 3
m_3b1 <- m_3 %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_3b1 <- m_3b1[!st_is_empty(m_3b1), , drop = FALSE]

m_3b2 <- m_3b1 %>% 
  st_truchet_dissolve() %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_3b2 <- m_3b2[!st_is_empty(m_3b2), , drop = FALSE]

# Container 2
m_2b1 <- m_2 %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_2b1 <- m_2b1[!st_is_empty(m_2b1), , drop = FALSE]

m_2b2 <- m_2b1 %>% 
  st_truchet_dissolve() %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_2b2 <- m_2b2[!st_is_empty(m_2b2), , drop = FALSE]

# Container 1
m_1b1 <- m_1 %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_1b1 <- m_1b1[!st_is_empty(m_1b1), , drop = FALSE]

m_1b2 <- m_1b1 %>% 
  st_truchet_dissolve() %>% 
  st_buffer(dist = -0.1) %>%
  mutate(color = color + 2)

m_1b2 <- m_1b2[!st_is_empty(m_1b2), , drop = FALSE]
```

```{r}
m_4_lines <- rbind(m_4 %>% 
                     st_cast(to = "MULTILINESTRING"),
                   m_4b1 %>%
                     st_cast(to = "MULTILINESTRING"),
                   m_4b2 %>% 
                     st_cast(to = "MULTILINESTRING"))

m_3_lines <- rbind(m_3 %>% 
                     st_cast(to = "MULTILINESTRING"),
                   m_3b1 %>%
                     st_cast(to = "MULTILINESTRING"),
                   m_3b2 %>% 
                     st_cast(to = "MULTILINESTRING"))

m_2_lines <- rbind(m_2 %>% 
                     st_cast(to = "MULTILINESTRING"),
                   m_2b1 %>%
                     st_cast(to = "MULTILINESTRING"),
                   m_2b2 %>% 
                     st_cast(to = "MULTILINESTRING"))

m_1_lines <- rbind(m_1 %>% 
                     st_cast(to = "MULTILINESTRING"),
                   m_1b1 %>%
                     st_cast(to = "MULTILINESTRING"),
                   m_1b2 %>% 
                     st_cast(to = "MULTILINESTRING"))
```

Then scale and recenter:
```{r}
m_4_union <- (m_4_lines * s) %>%
  st_sf()

m_3_union <- (m_3_lines * s) %>% 
  st_sf()

m_2_union <- (m_2_lines * s) %>% 
  st_sf()

m_1_union <- (m_1_lines * s) %>% 
  st_sf()
```

```{r eval = FALSE}
ggplot() + 
  geom_sf(data = m_4_union,
          color = "blue") + 
  geom_sf(data = m_3_union,
          color = "green") + 
  geom_sf(data = m_2_union,
          color = "red") + 
  geom_sf(data = m_1_union,
          color = "orange")
```

Create a grid for the blade:
```{r}
bbox <- st_bbox(container) %>% 
  round()

blade <- data.frame(x_start = c(bbox$xmin:bbox$xmax, 
                                rep(bbox$ymin, 
                                    length(bbox$ymin:bbox$ymax))),
                    x_end = c(bbox$xmin:bbox$xmax, 
                              rep(bbox$xmax, 
                                  length(bbox$ymin:bbox$ymax))),
                    y_start = c(rep(bbox$ymin, 
                                    length(bbox$xmin:bbox$xmax)),
                                bbox$ymin:bbox$ymax),
                    y_end = c(rep(bbox$ymax,
                                  length(bbox$xmin:bbox$xmax)),
                              bbox$ymin:bbox$ymax))

# Shift the blade a small amount to avoid perfect overlap with underlying grid
blade <- blade %>%
  mutate(across(everything(), 
                ~ .x + 0.28))

blade <- pmap(blade, function(x_start, x_end, y_start, y_end){
  st_linestring(
    matrix(
      c(
        x_start,
        y_start,
        x_end,
        y_end),
      ncol = 2,byrow = TRUE)
  )
}) %>%
  st_as_sfc()
```

Use the blade _and_ the paths to split the lines:
```{r}
# Part 1
mosaic_lines_1 <- m_1_union %>%
  st_split(blade) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  st_split(paths) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  mutate(id = "1")

# Part 2
mosaic_lines_2 <- m_2_union %>%
  st_split(blade) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  st_split(paths) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  mutate(id = "2")

# Part 3
mosaic_lines_3 <- m_3_union %>%
  st_split(blade) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  st_split(paths) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  mutate(id = "3")

# Part 4
mosaic_lines_4 <- m_4_union %>%
  st_split(blade) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  st_split(paths) %>%
  st_collection_extract(type = "LINESTRING") %>%
  st_cast(to = "LINESTRING") %>%
  mutate(id = "4")
```

Extract the geometries and select the line segments that are within each of the container polygons:
```{r}
# mosaic_lines_1 <- mosaic_lines_1[container %>% filter(id == "1"),]
# 
#mosaic_lines_2 <- mosaic_lines_2[container %>% filter(id == "2"),]

#mosaic_lines_3 <- mosaic_lines_3[container %>% filter(id == "3"),]
# 
# mosaic_lines_4 <- mosaic_lines_4[container %>% filter(id == "4"),]

```

Put together:
```{r}
# mosaic_lines <- rbind(mosaic_lines_1[container %>% filter(id == "1"),],
#                       mosaic_lines_2[container %>% filter(id == "2"),],
#                       mosaic_lines_3[container %>% filter(id == "3"),],
#                       mosaic_lines_4[container %>% filter(id == "4"),])
mosaic_lines <- rbind(mosaic_lines_1,
                      mosaic_lines_2[container %>% filter(id == "2"),],
                      mosaic_lines_3[container %>% filter(id == "3"),],
                      mosaic_lines_4)
```

Find the nearest feature and borrow tones of gray and hexadecimal colors:
```{r}
colors_df <- df_sf[mosaic_lines %>% 
                     st_nearest_feature(df_sf),]
```

We can now add the greyscale values and hexadecimal colors to the data frame with the mosaic:
```{r}
mosaic_lines$value <- colors_df$value
#mosaic_lines$hex_color <- colors_df$hex_color
```

Create parts of mosaic:
```{r}
sky_1 <- container %>% 
  filter(id == 4) %>% 
  st_buffer(dist = 3) %>% 
  st_crop(container)

sky_2 <- container %>% 
  filter(id == 1) %>% 
  st_buffer(dist = 9) %>% 
  st_crop(container)

cloud <- container %>% 
  filter(id == 2) %>% 
  st_buffer(dist = 9) %>% 
  st_crop(container)
```

Plot mosaic (monotone):
```{r}
# Choose color palette
palette_name <- sample(c("Revolucion", "Atentado", "Alacena", "Ronda"), 1)

# Color palette
col_palette <- mex.brewer(palette_name)

ggplot() +
  geom_sf(data = cloud,
          color = NA,
          fill = "white") +
  geom_sf(data = mosaic_lines %>%
            filter(id == 2 | id == 3) %>%
            st_crop(df_sf),
          aes(size = exp(-5 * value),
              color = value)) +
  scale_color_gradientn(colors = col_palette[1:5]) +
  scale_size(range = c(0.01, 1.3)) + 
  ggnewscale::new_scale("size") +
  geom_sf(data = sky_2,
          color = "black",
          fill = col_palette[sample.int(10, 1)]) +
  geom_sf(data = mosaic_lines[sky_2,] %>%
            filter(id == "1") %>%
            st_crop(df_sf),
          aes(size = exp(1 * value)),
          color = "white") +
  scale_size(range = c(0.01, 0.3)) +
  geom_sf(data = sky_1, 
          color = "black",
          fill = col_palette[sample.int(10, 1)]) +
  geom_sf(data = mosaic_lines[sky_1,] %>%
            filter(id == "4") %>%
            st_crop(df_sf),
          aes(size = exp(1 * value)),
          color = "white") +
  coord_sf(expand = FALSE) + 
  theme_void() + 
  theme(legend.position = "none",
        plot.margin = margin(0.1, 0.1, 0.1, 0.1, "in"))

ggsave(glue::glue("truchet-clouds-{palette_name}-{seed}.png"),
       height = 7,
       width = 7,
       units = "in")
```

